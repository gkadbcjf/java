                         class Number{
	static int num =0; //클래스 필드
	int num2 = 0; //인스턴스 필드
}
public class Main_ex {

	//클래스 : 객체를 만들기위한 설계도 데이터,메소드들의 집합
	//객체지향프로그래밍? 현실세계의 어떤 사물이나 물체를 컴퓨터에 추상화하여 
	//이들끼리 상호작용하는 프로그램설계법
	//객체 : (현실세계에 있는) 물체나,사물을 소프트웨어로 구현시키기 위할 대상
	
	//객체 지향 프로그래밍을 했을 때 장점이 뭐에요?"
	/* 
	 * 다른 이가 만든 클래스를 불러와 코드를 재사용할 수 있고 오브젝트간의 독립성이 유지되어야 하기 때문에
	 * 어떤 오류가 발생했을 때 어느 부분에서 문제가 발생했는지 찾기가 쉬워 유지보수에 용이합니다.
	 */
	//단점은요? 객체지향언어는 대체적으로 실행속도가 느리고 객체를 처리하려는 것에 대한 정확한 이해가
	//필요하기에 설계단계에서 많은 시간이 소요됩니다.
	
	
	/*"객체 지향 프로그래밍의 특징을 말씀해주세요"
	 * 1.캡슐화 2.추상화 3.상속 4.다형성
	 * 추상화 : 현실 세계에 있는 무언가에 핵심을 강조해 단순하게 모델링하는 것
	 * 캡슐화 : 외부로 부터 데이터 접근을 막고 추상화로 정의된 속성과 기능을 하나로 묶어 관리할 수 있고
	 * 상속 : 부모 클래스에 정의된 변수나 메소드를 자식클레스에 상속 받아서 사용해주는 것
	 * 다형성 : 객체의 속성이나 기능이 다양하게 구현될 수 있게 하는 것입니다.
*/
	
	
	/* 객체 지향 프로그래밍의 5가지 설계 원칙 설명해 주세요 (SOLID)
	 * 의인 단개리
	 * 의존관계 역전원칙, 인터페이스 분리 원칙, 단일 책임 원칙, 개방 폐쇠 원칙, 리스코프 치환법칙
	 * 단일 책임 원칙(SRP : Single Responsibility Principle)
	 * -한 클래스는 하나의 책임만 가진다.
	 * 
	 * 개방 폐쇠 원칙(OCP : Open/Closed Principle)
	 * -확장에는 열려있으나 변경에는 닫혀있어야 한다.
	 * 
	 * 리스코프 치환 원칙(LSP : Liskov's Subsitiution Principle)
	 * -프로그램의 객체는 프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
	 * 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 함
	 * 
	 * 인터페이스 분리 원칙(ISP : Interface Segregation Principle)
	 * -특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
	 * 	클라이언트는 이용하지 않는 메소드에 의존하지 않도록 분리
	 * 
	 * 의존관계 역전 원칙 (DIP : Dependency Inversion Principle)
	 * -추상화에 의존한다. 구체화에 의존하면 안된다.
	 */
	
	
	
	/*상속  : 기존의 클래스에 기능을 추가하고 재정의하는 것
	다른 클래스가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스에서 직접 만들지 않고
	상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능*/
	
	//목적? 클래스의 재사용, 연관된 일련의 클래스들에 대한 공통적인 규약 정의
	//장점? 1. 보다 적은 양의 코드로 새로운 클래스 작성 가능
	//	   2. 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
	//	   3. 코드의 중복을 제거d하여 프로그램의 생산성과 유지보수에 크게 기여
	
	
	/*다형성 : 소프트웨어를 작은 단위로 나눈 것을 모듈이라고 
	 * 
	 */
	
	
	
	/*모듈화 ?  소프트웨어를 작은 단위로 나눈 것을 모듈이라고 하고 
	 * 이 작은 논리적으로 구성된 것을 의미한다.
	 * 예시 각 기능을 가진 클래스들을 객체로 인스턴스화 시켜 동작가능하게 해주는 것
	 * 
	 * 
	 */
	
	/*접근제한자 크기 순서대로 각각 설명해주세요 :
		public > protected >default > private 순으로 
		public은 해당패키지에서 다른 패키지에서도 사용가능
		protected는 해당패키지 외 다른 패키지도 사용가능하나 상속일 경우에만 가능
		default는 해당 패키지에서만 가능
		private는 선언된 해당 클레스내에서만 가능
		
	*/
	
	/*캡슐화,정보은닉
	 * 추상화를 통해 정의던 객체의 필드와 메소드들을 하나로 묶어 관리하도록 하는 기법으로
	 * 데이터 접근제한(정보은닉)을 원칙으로 외부에서 데이터를 접근을 막도록 해준다.
	 */
	
	/*오버로딩과 오버라이딩 설명
	 * 오버로딩은 이름이 같은 메소드들의 매개변수의 개수나 유형을 다르게 가진 기술
	 * 오버라이딩은 부모 클래스의 메소드를 자식클래스에서 재정의 가능하도록 해주는 기술
	 */
	
	//인스턴스 : 클래스 기반으로 실제 메모리에 할당된 객체
	
	//java7 8의 차이
	//permanet가 사라진 이유
	//metadata?
	/*static? 각 객체들에게 하나의 값으로 유지되어야 할 경우 사용되며 static메모리를 생성과 동시에 
	메모리에 고정적으로 할당시키고 객체 생성없이 사용가능하게 해줌
	
	
	static단점
	-static메서드는 static영역 안에서만 존재하기 때문에 gc로부터 메모리 관리를 자동으로 받을 수 없다.
	떄문에 과도하게 많이 사용하면 메모리 과부화가 발생할 수 있다. 또한 프로그램 시작할 때 static 영역의 메모리 크기를
	넘으면 시작과 동시에 에러 발생
	
	예외
	사용자가 에러를 예측하고 수정가능한 작업
	
	예외처리
	예외가 발생했을 경우에 처리하는 방법
	
	에러 종류
	시스템 에러 : 컴퓨터 자체 또는 기계에 문제가 있을 때 발생
	컴파일 에러 : 코드 자체에 문제가 생겨 발생되는 오류 
	런타임 에러 : 코드상에 문제는 없지만 실행 후 발생하는 오류
	논리 에러 : 코드와 실행에는 문제가 없지만 사용자의도와 다르게 동작할 때 발생하는 것
	
	
	
	*/

	
	
	
	
	
	
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Integer i = new Integer(1);
		Integer num =10;
		num = new Integer(num.intValue()+3);
		num = num.intValue()+3;
		System.out.println(num);
		num.valueOf(0);
		
//		Number number1 = new Number();
//		Number number2 = new Number();
//		Number.num=3; //객체 생성 없이도 값을 지정할 수 있다.
//		
//		number1.num++; //영향을 줌
//		number1.num2++; //영향을 주지못함
//		
//		System.out.println(number2.num);
//		System.out.println(number2.num2);
		
	}

}
